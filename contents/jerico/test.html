<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>baseFillから-3～0で変化するグラフ</title>
    <style>
      body {
        font-family: sans-serif;
      }
      canvas {
        background-color: #f0f0f0;
        display: block;
        margin: 20px auto;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      // キャンバス全体の設定
      const canvasWidth = 800;
      const canvasHeight = 600;
      const labelWidth = 150; // ラベル表示用の横幅
      const marginLeft = labelWidth + 20; // グラフ描画開始位置（ラベル分の余白を確保）
      const marginTop = 30; // 上部余白
      const statusSpacing = 80; // 各ステータス間の縦間隔
      const fontSize = 24; // ラベルのフォントサイズ

      const canvas = document.getElementById("canvas");
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext("2d");

      // 各ステータスの設定（baseFill を基本値として currentFill と targetFill を管理）
      const statuses = [
        {
          label: "Body",
          totalSegments: 20,
          baseFill: 12,
          currentFill: 12,
          targetFill: 12,
        },
        {
          label: "Sense",
          totalSegments: 20,
          baseFill: 15,
          currentFill: 15,
          targetFill: 15,
        },
        {
          label: "Mind",
          totalSegments: 20,
          baseFill: 10,
          currentFill: 10,
          targetFill: 10,
        },
        {
          label: "Social",
          totalSegments: 20,
          baseFill: 18,
          currentFill: 18,
          targetFill: 18,
        },
      ];

      // グラフ描画用パラメータ
      const segmentWidth = 20; // 各セグメントの横幅
      const segmentHeight = 30; // 各セグメントの高さ
      const gap = 3; // セグメント間の隙間

      // グラデーション設定（赤～オレンジ）
      let time = 0;
      const speed = 1;
      const minHue = 0;
      const maxHue = 30;
      const hueRange = maxHue - minHue;

      let frameCount = 0;
      const updateInterval = 60; // 更新間隔（例：60フレームごとに targetFill を更新）

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        frameCount++;

        // updateInterval ごとに、targetFill を baseFill から -3～0 の範囲内で更新
        if (frameCount % updateInterval === 0) {
          statuses.forEach((status) => {
            // Math.floor(Math.random() * 4) は 0～3 の整数を返すので、baseFill - 0～3 となる
            status.targetFill = status.baseFill - Math.floor(Math.random() * 4);
          });
        }

        statuses.forEach((status, index) => {
          // targetFill に向けて currentFill を段階的に更新（1ずつ増減）
          if (status.currentFill < status.targetFill) {
            status.currentFill++;
          } else if (status.currentFill > status.targetFill) {
            status.currentFill--;
          }
          // クランプ処理（万が一オーバーしないように）
          status.currentFill = Math.min(
            Math.max(status.currentFill, status.baseFill - 3),
            status.baseFill
          );
          const filledSegments = status.currentFill;

          const yOffset = marginTop + index * statusSpacing;

          // ラベル描画
          ctx.fillStyle = "#000";
          ctx.font = `${fontSize}px "Courier New", Courier, monospace`;
          ctx.textBaseline = "middle";
          ctx.fillText(status.label, 10, yOffset + segmentHeight / 2);

          // セグメント描画
          for (let i = 0; i < status.totalSegments; i++) {
            const x = marginLeft + i * (segmentWidth + gap);
            if (i < filledSegments) {
              const hue = minHue + ((time * speed + i * 3) % (hueRange + 1));
              ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;
            } else {
              ctx.fillStyle = "rgba(200, 200, 200, 1)";
            }
            ctx.fillRect(x, yOffset, segmentWidth, segmentHeight);
          }
        });

        time++;
        requestAnimationFrame(draw);
      }

      draw();
    </script>
  </body>
</html>
